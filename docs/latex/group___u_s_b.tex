\hypertarget{group___u_s_b}{}\doxysection{U\+SB Driver}
\label{group___u_s_b}\index{USB Driver@{USB Driver}}


Generic U\+SB Driver.  


Collaboration diagram for U\+SB Driver\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=266pt]{group___u_s_b}
\end{center}
\end{figure}
Generic U\+SB Driver. 

This module implements a generic U\+SB (Universal Serial Bus) driver supporting device-\/mode operations. \begin{DoxyPrecond}{Precondition}
In order to use the U\+SB driver the {\ttfamily H\+A\+L\+\_\+\+U\+S\+E\+\_\+\+U\+SB} option must be enabled in {\ttfamily halconf.\+h}.
\end{DoxyPrecond}
\hypertarget{group___u_s_b_usb_1}{}\doxysubsection{Driver State Machine}\label{group___u_s_b_usb_1}
The driver implements a state machine internally, not all the driver functionalities can be used in any moment, any transition not explicitly shown in the following diagram has to be considered an error and shall be captured by an assertion (if enabled). 
\begin{DoxyImageNoCaption}
  \mbox{\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{dot_inline_dotgraph_16}}
\end{DoxyImageNoCaption}
\hypertarget{group___u_s_b_usb_2}{}\doxysubsection{U\+S\+B Operations}\label{group___u_s_b_usb_2}
The U\+SB driver is quite complex and U\+SB is complex in itself, it is recommended to study the U\+SB specification before trying to use the driver.\hypertarget{group___u_s_b_usb_2_1}{}\doxysubsubsection{U\+S\+B Implementation}\label{group___u_s_b_usb_2_1}
The U\+SB driver abstracts the inner details of the underlying U\+SB hardware. The driver works asynchronously and communicates with the application using callbacks. The application is responsible of the descriptors and strings required by the U\+SB device class to be implemented and of the handling of the specific messages sent over the endpoint zero. Standard messages are handled internally to the driver. The application can use hooks in order to handle custom messages or override the handling of the default handling of standard messages.\hypertarget{group___u_s_b_usb_2_2}{}\doxysubsubsection{U\+S\+B Endpoints}\label{group___u_s_b_usb_2_2}
U\+SB endpoints are the objects that the application uses to exchange data with the host. There are two kind of endpoints\+:
\begin{DoxyItemize}
\item {\bfseries{IN}} endpoints are used by the application to transmit data to the host.~\newline

\item {\bfseries{O\+UT}} endpoints are used by the application to receive data from the host.
\end{DoxyItemize}The driver invokes a callback after finishing an IN or O\+UT transaction. States diagram for O\+UT endpoints in transaction mode\+: 
\begin{DoxyImageNoCaption}
  \mbox{\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{dot_inline_dotgraph_17}}
\end{DoxyImageNoCaption}
 ~\newline
~\newline
 States diagram for IN endpoints in transaction mode\+: 
\begin{DoxyImageNoCaption}
  \mbox{\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{dot_inline_dotgraph_18}}
\end{DoxyImageNoCaption}
 ~\newline
~\newline
\hypertarget{group___u_s_b_usb_2_4}{}\doxysubsubsection{U\+S\+B Callbacks}\label{group___u_s_b_usb_2_4}
The U\+SB driver uses callbacks in order to interact with the application. There are several kinds of callbacks to be handled\+:
\begin{DoxyItemize}
\item Driver events callback. As example errors, suspend event, reset event etc.
\item Messages Hook callback. This hook allows the application to implement handling of custom messages or to override the default handling of standard messages on endpoint zero.
\item Descriptor Requested callback. When the driver endpoint zero handler receives a G\+ET D\+E\+S\+C\+R\+I\+P\+T\+OR message and needs to send a descriptor to the host it queries the application using this callback.
\item Start of Frame callback. This callback is invoked each time a S\+OF packet is received.
\item Endpoint callbacks. Each endpoint informs the application about I/O conditions using those callbacks.
\end{DoxyItemize}