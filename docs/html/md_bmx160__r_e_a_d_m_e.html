<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SD_Modules: BMI160 sensor API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SD_Modules
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Code modules used in SailData firmwares</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_bmx160__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">BMI160 sensor API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md12"></a>
Introduction</h1>
<p>This package contains the Bosch Sensortec's BMI160 sensor driver (sensor API)</p>
<p>The sensor driver package includes <a class="el" href="bmi160_8h.html">bmi160.h</a>, <a class="el" href="bmi160_8c.html">bmi160.c</a> and <a class="el" href="bmi160__defs_8h.html">bmi160_defs.h</a> files</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Version</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File </th><th class="markdownTableHeadNone">Version </th><th class="markdownTableHeadNone">Date  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="bmi160_8c.html">bmi160.c</a> </td><td class="markdownTableBodyNone">3.7.7 </td><td class="markdownTableBodyNone">13 Mar 2019  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="bmi160_8h.html">bmi160.h</a> </td><td class="markdownTableBodyNone">3.7.7 </td><td class="markdownTableBodyNone">13 Mar 2019  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="bmi160__defs_8h.html">bmi160_defs.h</a> </td><td class="markdownTableBodyNone">3.7.7 </td><td class="markdownTableBodyNone">13 Mar 2019  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md14"></a>
Integration details</h1>
<ul>
<li>Integrate <a class="el" href="bmi160_8h.html">bmi160.h</a>, <a class="el" href="bmi160__defs_8h.html">bmi160_defs.h</a> and <a class="el" href="bmi160_8c.html">bmi160.c</a> file in to your project.</li>
<li>Include the <a class="el" href="bmi160_8h.html">bmi160.h</a> file in your code like below. <div class="fragment"><div class="line">#include &quot;bmi160.h&quot;</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
File information</h1>
<ul>
<li><a class="el" href="bmi160__defs_8h.html">bmi160_defs.h</a> : This header file has the constants, macros and datatype declarations.</li>
<li><a class="el" href="bmi160_8h.html">bmi160.h</a> : This header file contains the declarations of the sensor driver APIs.</li>
<li><a class="el" href="bmi160_8c.html">bmi160.c</a> : This source file contains the definitions of the sensor driver APIs.</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Supported sensor interface</h1>
<ul>
<li>SPI 4-wire</li>
<li>I2C</li>
</ul>
<h1><a class="anchor" id="autotoc_md17"></a>
Usage guide</h1>
<h2><a class="anchor" id="autotoc_md18"></a>
Initializing the sensor</h2>
<p>To initialize the sensor, you will first need to create a device structure. You can do this by creating an instance of the structure <a class="el" href="structbmi160__dev.html">bmi160_dev</a>. Then go on to fill in the various parameters as shown below.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Example for SPI 4-Wire</h3>
<div class="fragment"><div class="line">struct bmi160_dev sensor;</div>
<div class="line"> </div>
<div class="line">/* You may assign a chip select identifier to be handled later */</div>
<div class="line">sensor.id = 0;</div>
<div class="line">sensor.interface = BMI160_SPI_INTF;</div>
<div class="line">sensor.read = user_spi_read;</div>
<div class="line">sensor.write = user_spi_write;</div>
<div class="line">sensor.delay_ms = user_delay_ms;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">rslt = bmi160_init(&amp;sensor);</div>
<div class="line">/* After the above function call, accel_cfg and gyro_cfg parameters in the device </div>
<div class="line">structure are set with default values, found in the datasheet of the sensor */</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
Example for I2C</h3>
<div class="fragment"><div class="line">struct bmi160_dev sensor;</div>
<div class="line"> </div>
<div class="line">sensor.id = BMI160_I2C_ADDR;</div>
<div class="line">sensor.interface = BMI160_I2C_INTF;</div>
<div class="line">sensor.read = user_i2c_read;</div>
<div class="line">sensor.write = user_i2c_write;</div>
<div class="line">sensor.delay_ms = user_delay_ms;</div>
<div class="line"> </div>
<div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">rslt = bmi160_init(&amp;sensor);</div>
<div class="line">/* After the above function call, accel and gyro parameters in the device structure </div>
<div class="line">are set with default values, found in the datasheet of the sensor */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Configuring accel and gyro sensor</h2>
<h3><a class="anchor" id="autotoc_md22"></a>
Example for configuring accel and gyro sensors in normal mode</h3>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line"> </div>
<div class="line">/* Select the Output data rate, range of accelerometer sensor */</div>
<div class="line">sensor.accel_cfg.odr = BMI160_ACCEL_ODR_1600HZ;</div>
<div class="line">sensor.accel_cfg.range = BMI160_ACCEL_RANGE_2G;</div>
<div class="line">sensor.accel_cfg.bw = BMI160_ACCEL_BW_NORMAL_AVG4;</div>
<div class="line"> </div>
<div class="line">/* Select the power mode of accelerometer sensor */</div>
<div class="line">sensor.accel_cfg.power = BMI160_ACCEL_NORMAL_MODE;</div>
<div class="line"> </div>
<div class="line">/* Select the Output data rate, range of Gyroscope sensor */</div>
<div class="line">sensor.gyro_cfg.odr = BMI160_GYRO_ODR_3200HZ;</div>
<div class="line">sensor.gyro_cfg.range = BMI160_GYRO_RANGE_2000_DPS;</div>
<div class="line">sensor.gyro_cfg.bw = BMI160_GYRO_BW_NORMAL_MODE;</div>
<div class="line"> </div>
<div class="line">/* Select the power mode of Gyroscope sensor */</div>
<div class="line">sensor.gyro_cfg.power = BMI160_GYRO_NORMAL_MODE; </div>
<div class="line"> </div>
<div class="line">/* Set the sensor configuration */</div>
<div class="line">rslt = bmi160_set_sens_conf(&amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Reading sensor data</h2>
<h3><a class="anchor" id="autotoc_md24"></a>
Example for reading sensor data</h3>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">struct bmi160_sensor_data accel;</div>
<div class="line">struct bmi160_sensor_data gyro;</div>
<div class="line"> </div>
<div class="line">/* To read only Accel data */</div>
<div class="line">rslt = bmi160_get_sensor_data(BMI160_ACCEL_SEL, &amp;accel, NULL, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* To read only Gyro data */</div>
<div class="line">rslt = bmi160_get_sensor_data(BMI160_GYRO_SEL, NULL, &amp;gyro, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* To read both Accel and Gyro data */</div>
<div class="line">bmi160_get_sensor_data((BMI160_ACCEL_SEL | BMI160_GYRO_SEL), &amp;accel, &amp;gyro, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* To read Accel data along with time */</div>
<div class="line">rslt = bmi160_get_sensor_data((BMI160_ACCEL_SEL | BMI160_TIME_SEL) , &amp;accel, NULL, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* To read Gyro data along with time */</div>
<div class="line">rslt = bmi160_get_sensor_data((BMI160_GYRO_SEL | BMI160_TIME_SEL), NULL, &amp;gyro, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* To read both Accel and Gyro data along with time*/</div>
<div class="line">bmi160_get_sensor_data((BMI160_ACCEL_SEL | BMI160_GYRO_SEL | BMI160_TIME_SEL), &amp;accel, &amp;gyro, &amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
Setting the power mode of sensors</h2>
<h3><a class="anchor" id="autotoc_md26"></a>
Example for setting power mode of accel and gyro</h3>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line"> </div>
<div class="line">/* Select the power mode */</div>
<div class="line">sensor.accel_cfg.power = BMI160_ACCEL_SUSPEND_MODE; </div>
<div class="line">sensor.gyro_cfg.power = BMI160_GYRO_FASTSTARTUP_MODE; </div>
<div class="line"> </div>
<div class="line">/*  Set the Power mode  */</div>
<div class="line">rslt = bmi160_set_power_mode(&amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* Select the power mode */</div>
<div class="line">sensor.accel_cfg.power = BMI160_ACCEL_NORMAL_MODE;</div>
<div class="line">sensor.gyro_cfg.power = BMI160_GYRO_NORMAL_MODE; </div>
<div class="line"> </div>
<div class="line">/*  Set the Power mode  */</div>
<div class="line">rslt = bmi160_set_power_mode(&amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Reading sensor data register</h2>
<h3><a class="anchor" id="autotoc_md28"></a>
Example for reading Chip Address</h3>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">uint8_t reg_addr = BMI160_CHIP_ID_ADDR;</div>
<div class="line">uint8_t data;</div>
<div class="line">uint16_t len = 1;</div>
<div class="line">rslt = bmi160_get_regs(reg_addr, &amp;data, len, &amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
Writing to sensor data register</h2>
<h3><a class="anchor" id="autotoc_md30"></a>
Example for writing data to any motion threshold register</h3>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">uint8_t reg_addr = BMI160_INT_MOTION_1_ADDR;</div>
<div class="line">uint8_t data = 20;</div>
<div class="line">uint16_t len = 1;</div>
<div class="line">rslt = bmi160_set_regs(reg_addr, &amp;data, len, &amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Resetting the device using soft-reset</h2>
<h3><a class="anchor" id="autotoc_md32"></a>
Example for writing soft-reset command to command register</h3>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">rslt = bmi160_soft_reset(&amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Configuring interrupts for sensors</h2>
<p>To configure the sensor interrupts, you will first need to create an interrupt structure. You can do this by creating an instance of the structure <a class="el" href="structbmi160__int__settg.html">bmi160_int_settg</a>. Then go on to fill in the various parameters as shown below</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Configuring Any-motion Interrupt</h2>
<h3><a class="anchor" id="autotoc_md35"></a>
Example for configuring Any-motion Interrupt</h3>
<p>Note:- User can check the currently active interrupt(any-motion or sig-motion) by checking the <b>any_sig_sel</b> of <a class="el" href="structbmi160__dev.html">bmi160_dev</a> structure. </p><div class="fragment"><div class="line">struct bmi160_int_settg int_config;</div>
<div class="line"> </div>
<div class="line">/* Select the Interrupt channel/pin */</div>
<div class="line">int_config.int_channel = BMI160_INT_CHANNEL_1;// Interrupt channel/pin 1</div>
<div class="line"> </div>
<div class="line">/* Select the Interrupt type */</div>
<div class="line">int_config.int_type = BMI160_ACC_ANY_MOTION_INT;// Choosing Any motion interrupt</div>
<div class="line">/* Select the interrupt channel/pin settings */</div>
<div class="line">int_config.int_pin_settg.output_en = BMI160_ENABLE;// Enabling interrupt pins to act as output pin</div>
<div class="line">int_config.int_pin_settg.output_mode = BMI160_DISABLE;// Choosing push-pull mode for interrupt pin</div>
<div class="line">int_config.int_pin_settg.output_type = BMI160_DISABLE;// Choosing active low output</div>
<div class="line">int_config.int_pin_settg.edge_ctrl = BMI160_ENABLE;// Choosing edge triggered output</div>
<div class="line">int_config.int_pin_settg.input_en = BMI160_DISABLE;// Disabling interrupt pin to act as input</div>
<div class="line">int_config.int_pin_settg.latch_dur = BMI160_LATCH_DUR_NONE;// non-latched output</div>
<div class="line"> </div>
<div class="line">/* Select the Any-motion interrupt parameters */</div>
<div class="line">int_config.int_type_cfg.acc_any_motion_int.anymotion_en = BMI160_ENABLE;// 1- Enable the any-motion, 0- disable any-motion </div>
<div class="line">int_config.int_type_cfg.acc_any_motion_int.anymotion_x = BMI160_ENABLE;// Enabling x-axis for any motion interrupt</div>
<div class="line">int_config.int_type_cfg.acc_any_motion_int.anymotion_y = BMI160_ENABLE;// Enabling y-axis for any motion interrupt</div>
<div class="line">int_config.int_type_cfg.acc_any_motion_int.anymotion_z = BMI160_ENABLE;// Enabling z-axis for any motion interrupt</div>
<div class="line">int_config.int_type_cfg.acc_any_motion_int.anymotion_dur = 0;// any-motion duration</div>
<div class="line">int_config.int_type_cfg.acc_any_motion_int.anymotion_thr = 20;// (2-g range) -&gt; (slope_thr) * 3.91 mg, (4-g range) -&gt; (slope_thr) * 7.81 mg, (8-g range) -&gt;(slope_thr) * 15.63 mg, (16-g range) -&gt; (slope_thr) * 31.25 mg </div>
<div class="line"> </div>
<div class="line">/* Set the Any-motion interrupt */</div>
<div class="line">bmi160_set_int_config(&amp;int_config, &amp;sensor); /* sensor is an instance of the structure bmi160_dev  */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Configuring Flat Interrupt</h2>
<h3><a class="anchor" id="autotoc_md37"></a>
Example for configuring Flat Interrupt</h3>
<div class="fragment"><div class="line">struct bmi160_int_settg int_config;</div>
<div class="line"> </div>
<div class="line">/* Select the Interrupt channel/pin */</div>
<div class="line">int_config.int_channel = BMI160_INT_CHANNEL_1;// Interrupt channel/pin 1</div>
<div class="line"> </div>
<div class="line">/* Select the Interrupt type */</div>
<div class="line">int_config.int_type = BMI160_ACC_FLAT_INT;// Choosing flat interrupt</div>
<div class="line">/* Select the interrupt channel/pin settings */</div>
<div class="line">int_config.int_pin_settg.output_en = BMI160_ENABLE;// Enabling interrupt pins to act as output pin</div>
<div class="line">int_config.int_pin_settg.output_mode = BMI160_DISABLE;// Choosing push-pull mode for interrupt pin</div>
<div class="line">int_config.int_pin_settg.output_type = BMI160_DISABLE;// Choosing active low output</div>
<div class="line">int_config.int_pin_settg.edge_ctrl = BMI160_ENABLE;// Choosing edge triggered output</div>
<div class="line">int_config.int_pin_settg.input_en = BMI160_DISABLE;// Disabling interrupt pin to act as input</div>
<div class="line">int_config.int_pin_settg.latch_dur = BMI160_LATCH_DUR_NONE;// non-latched output</div>
<div class="line"> </div>
<div class="line">/* Select the Flat interrupt parameters */</div>
<div class="line">int_config.int_type_cfg.acc_flat_int.flat_en = BMI160_ENABLE;// 1-enable, 0-disable the flat interrupt</div>
<div class="line">int_config.int_type_cfg.acc_flat_int.flat_theta = 8;// threshold for detection of flat position in range from 0° to 44.8°.</div>
<div class="line">int_config.int_type_cfg.acc_flat_int.flat_hy = 1;// Flat hysteresis</div>
<div class="line">int_config.int_type_cfg.acc_flat_int.flat_hold_time = 1;// Flat hold time (0 -&gt; 0 ms, 1 -&gt; 640 ms, 2 -&gt; 1280 ms, 3 -&gt; 2560 ms)</div>
<div class="line"> </div>
<div class="line">/* Set the Flat interrupt */</div>
<div class="line">bmi160_set_int_config(&amp;int_config, &amp;sensor); /* sensor is an instance of the structure bmi160_dev */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
Configuring Step Detector Interrupt</h2>
<h3><a class="anchor" id="autotoc_md39"></a>
Example for configuring Step Detector Interrupt</h3>
<div class="fragment"><div class="line">struct bmi160_int_settg int_config;</div>
<div class="line"> </div>
<div class="line">/* Select the Interrupt channel/pin */</div>
<div class="line">int_config.int_channel = BMI160_INT_CHANNEL_1;// Interrupt channel/pin 1</div>
<div class="line"> </div>
<div class="line">/* Select the Interrupt type */</div>
<div class="line">int_config.int_type = BMI160_STEP_DETECT_INT;// Choosing Step Detector interrupt</div>
<div class="line">/* Select the interrupt channel/pin settings */</div>
<div class="line">int_config.int_pin_settg.output_en = BMI160_ENABLE;// Enabling interrupt pins to act as output pin</div>
<div class="line">int_config.int_pin_settg.output_mode = BMI160_DISABLE;// Choosing push-pull mode for interrupt pin</div>
<div class="line">int_config.int_pin_settg.output_type = BMI160_ENABLE;// Choosing active High output</div>
<div class="line">int_config.int_pin_settg.edge_ctrl = BMI160_ENABLE;// Choosing edge triggered output</div>
<div class="line">int_config.int_pin_settg.input_en = BMI160_DISABLE;// Disabling interrupt pin to act as input</div>
<div class="line">int_config.int_pin_settg.latch_dur =BMI160_LATCH_DUR_NONE;// non-latched output</div>
<div class="line"> </div>
<div class="line">/* Select the Step Detector interrupt parameters, Kindly use the recommended settings for step detector */</div>
<div class="line">int_config.int_type_cfg.acc_step_detect_int.step_detector_mode = BMI160_STEP_DETECT_NORMAL;</div>
<div class="line">int_config.int_type_cfg.acc_step_detect_int.step_detector_en = BMI160_ENABLE;// 1-enable, 0-disable the step detector</div>
<div class="line"> </div>
<div class="line">/* Set the Step Detector interrupt */</div>
<div class="line">bmi160_set_int_config(&amp;int_config, &amp;sensor); /* sensor is an instance of the structure bmi160_dev */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Configuring Step counter</h2>
<p>To configure the step counter, user need to configure the step detector interrupt as described in above section. After configuring step detector, see the below code snippet for user space &amp; ISR</p>
<h2><a class="anchor" id="autotoc_md41"></a>
User space</h2>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">uint8_t step_enable = 1;//enable the step counter</div>
<div class="line"> </div>
<div class="line">rslt = bmi160_set_step_counter(step_enable,  &amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
ISR</h2>
<div class="fragment"><div class="line">int8_t rslt = BMI160_OK;</div>
<div class="line">uint16_t step_count = 0;//stores the step counter value</div>
<div class="line"> </div>
<div class="line">rslt = bmi160_read_step_counter(&amp;step_count,  &amp;sensor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md43"></a>
Unmapping Interrupt</h2>
<h3><a class="anchor" id="autotoc_md44"></a>
Example for unmapping Step Detector Interrupt</h3>
<div class="fragment"><div class="line">struct bmi160_int_settg int_config;</div>
<div class="line"> </div>
<div class="line">/* Deselect the Interrupt channel/pin */</div>
<div class="line">int_config.int_channel = BMI160_INT_CHANNEL_NONE;</div>
<div class="line">/* Select the Interrupt type */</div>
<div class="line">int_config.int_type = BMI160_STEP_DETECT_INT;// Choosing Step Detector interrupt</div>
<div class="line">/* Set the Step Detector interrupt */</div>
<div class="line">bmi160_set_int_config(&amp;int_config, &amp;sensor); /* sensor is an instance of the structure bmi160_dev */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md45"></a>
Reading interrupt status</h2>
<h3><a class="anchor" id="autotoc_md46"></a>
Example for reading interrupt status for step detector</h3>
<div class="fragment"><div class="line">union bmi160_int_status interrupt;</div>
<div class="line">enum bmi160_int_status_sel int_status_sel;</div>
<div class="line"> </div>
<div class="line">/* Interrupt status selection to read all interrupts */</div>
<div class="line">int_status_sel = BMI160_INT_STATUS_ALL;</div>
<div class="line">rslt = bmi160_get_int_status(int_status_sel, &amp;interrupt, &amp;sensor);</div>
<div class="line">if (interrupt.bit.step)</div>
<div class="line">    printf(&quot;Step detector interrupt occured\n&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md47"></a>
Configuring the auxiliary sensor BMM150</h2>
<p>It is assumed that secondary interface of bmi160 has external pull-up resistor in order to access the auxiliary sensor bmm150.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Accessing auxiliary BMM150 with BMM150 APIs via BMI160 secondary interface.</h2>
<h1><a class="anchor" id="autotoc_md49"></a>
Integration details</h1>
<ul>
<li>Integrate the souce codes of BMM150 and BMI160 in project.</li>
<li>Include the <a class="el" href="bmi160_8h.html">bmi160.h</a> and <a class="el" href="bmm150_8h.html">bmm150.h</a> file in your code like below.</li>
<li>It is mandatory to initialize the bmi160 device structure for primary interface and auxiliary sensor settings.</li>
<li>Create two wrapper functions , user_aux_read and user_aux_write in order to match the signature as mentioned below.</li>
<li>Invoke the "bmi160_aux_init" API to initialise the secondary interface in BMI160.</li>
<li>Invoke the "bmm150_init" API to initialise the BMM150 sensor.</li>
<li>Now we can use the BMM150 sensor APIs to access the BMM150 via BMI160.</li>
</ul>
<div class="fragment"><div class="line">/* main.c file */</div>
<div class="line">#include &quot;bmi160.h&quot;</div>
<div class="line">#include &quot;bmm150.h&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md50"></a>
Initialization of auxiliary sensor BMM150</h2>
<div class="fragment"><div class="line">/* main.c file */</div>
<div class="line">struct bmm150_dev bmm150;</div>
<div class="line"> </div>
<div class="line">/* function declaration */</div>
<div class="line">int8_t user_aux_read(uint8_t id, uint8_t reg_addr, uint8_t *aux_data, uint16_t len);</div>
<div class="line">int8_t user_aux_write(uint8_t id, uint8_t reg_addr, uint8_t *aux_data, uint16_t len);</div>
<div class="line"> </div>
<div class="line">/* Configure device structure for auxiliary sensor parameter */</div>
<div class="line">sensor.aux_cfg.aux_sensor_enable = 1; // auxiliary sensor enable</div>
<div class="line">sensor.aux_cfg.aux_i2c_addr = BMI160_AUX_BMM150_I2C_ADDR; // auxiliary sensor address</div>
<div class="line">sensor.aux_cfg.manual_enable = 1; // setup mode enable</div>
<div class="line">sensor.aux_cfg.aux_rd_burst_len = 2;// burst read of 2 byte</div>
<div class="line"> </div>
<div class="line">/* Configure the BMM150 device structure by </div>
<div class="line">mapping user_aux_read and user_aux_write */</div>
<div class="line">bmm150.read = user_aux_read;</div>
<div class="line">bmm150.write = user_aux_write;</div>
<div class="line">bmm150.id = BMM150_DEFAULT_I2C_ADDRESS; </div>
<div class="line">/* Ensure that sensor.aux_cfg.aux_i2c_addr = bmm150.id</div>
<div class="line">   for proper sensor operation */</div>
<div class="line">bmm150.delay_ms = delay_ms;</div>
<div class="line">bmm150.interface = BMM150_I2C_INTF;</div>
<div class="line"> </div>
<div class="line">/* Initialize the auxiliary sensor interface */</div>
<div class="line">rslt = bmi160_aux_init(&amp;sensor);</div>
<div class="line"> </div>
<div class="line">/* Auxiliary sensor is enabled and can be accessed from this point */</div>
<div class="line"> </div>
<div class="line">/* Configure the desired settings in auxiliary BMM150 sensor </div>
<div class="line"> * using the bmm150 APIs */</div>
<div class="line"> </div>
<div class="line">/* Initialising the bmm150 sensor */</div>
<div class="line">rslt = bmm150_init(&amp;bmm150);</div>
<div class="line"> </div>
<div class="line">/* Set the power mode and preset mode to enable Mag data sampling */</div>
<div class="line">bmm150.settings.pwr_mode = BMM150_NORMAL_MODE;</div>
<div class="line">rslt = bmm150_set_op_mode(&amp;bmm150);</div>
<div class="line"> </div>
<div class="line">bmm150.settings.preset_mode= BMM150_PRESETMODE_LOWPOWER;</div>
<div class="line">rslt = bmm150_set_presetmode(&amp;bmm150);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md51"></a>
Wrapper functions</h2>
<div class="fragment"><div class="line">/*wrapper function to match the signature of bmm150.read */</div>
<div class="line">int8_t user_aux_read(uint8_t id, uint8_t reg_addr, uint8_t *aux_data, uint16_t len)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line">    </div>
<div class="line">    /* Discarding the parameter id as it is redundant*/</div>
<div class="line">        rslt = bmi160_aux_read(reg_addr, aux_data, len, &amp;bmi160);</div>
<div class="line"> </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/*wrapper function to match the signature of bmm150.write */</div>
<div class="line">int8_t user_aux_write(uint8_t id, uint8_t reg_addr, uint8_t *aux_data, uint16_t len)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line">    </div>
<div class="line">    /* Discarding the parameter id as it is redundant */</div>
<div class="line">    rslt = bmi160_aux_write(reg_addr, aux_data, len, &amp;bmi160);</div>
<div class="line"> </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
Initialization of auxiliary BMM150 in auto mode</h2>
<p>Any sensor whose data bytes are less than or equal to 8 bytes can be synchronized with the BMI160 and read out of Accelerometer + Gyroscope + Auxiliary sensor data of that instance is possible which helps in creating less latency fusion data</p>
<div class="fragment"><div class="line">/* Initialize the Auxiliary BMM150 following the above code </div>
<div class="line"> * until setting the power mode (Set the power mode as forced mode)</div>
<div class="line"> * and preset mode */</div>
<div class="line"> </div>
<div class="line">    /* In BMM150 Mag data starts from register address 0x42 */</div>
<div class="line">    uint8_t aux_addr = 0x42;</div>
<div class="line">    /* Buffer to store the Mag data from 0x42 to 0x48 */    </div>
<div class="line">    uint8_t mag_data[8] = {0};</div>
<div class="line">    </div>
<div class="line">    uint8_t index;</div>
<div class="line">        </div>
<div class="line">    /* Configure the Auxiliary sensor either in auto/manual modes and set the </div>
<div class="line">    polling frequency for the Auxiliary interface */    </div>
<div class="line">    sensor.aux_cfg.aux_odr = 8; /* Represents polling rate in 100 Hz*/</div>
<div class="line">    rslt = bmi160_config_aux_mode(&amp;sensor)</div>
<div class="line">    </div>
<div class="line">    /* Set the auxiliary sensor to auto mode */</div>
<div class="line">    rslt = bmi160_set_aux_auto_mode(&amp;aux_addr, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">    /* Reading data from BMI160 data registers */</div>
<div class="line">    rslt = bmi160_read_aux_data_auto_mode(mag_data, &amp;sensor);</div>
<div class="line"> </div>
<div class="line">    printf(&quot;\n RAW DATA &quot;);</div>
<div class="line">    for(index = 0 ; index &lt; 8 ; index++)</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;\n MAG DATA[%d] : %d &quot;, index, mag_data[index]);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    /* Compensating the raw mag data available from the BMM150 API */</div>
<div class="line">    rslt = bmm150_aux_mag_data(mag_data, &amp;bmm150);</div>
<div class="line">    </div>
<div class="line">    printf(&quot;\n COMPENSATED DATA &quot;);</div>
<div class="line">    printf(&quot;\n MAG DATA X : %d Y : %d Z : %d&quot;, bmm150.data.x, bmm150.data.y, bmm150.data.z);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md53"></a>
Auxiliary FIFO data parsing</h2>
<p>The Auxiliary sensor data can be stored in FIFO , Here we demonstrate an example for using the Bosch Magnetometer sensor BMM150 and storing its data in FIFO</p>
<div class="fragment"><div class="line">/* Initialize the Aux BMM150 following the above </div>
<div class="line"> * code and by creating the Wrapper functions */</div>
<div class="line"> </div>
<div class="line">    int8_t rslt = 0;</div>
<div class="line">    uint8_t aux_instance = 0;</div>
<div class="line">    uint16_t fifo_cnt = 0;</div>
<div class="line">    uint8_t auto_mode_addr;</div>
<div class="line">    uint8_t i;</div>
<div class="line"> </div>
<div class="line">    /* Setup and configure the FIFO buffer */</div>
<div class="line">    /* Declare memory to store the raw FIFO buffer information */</div>
<div class="line">    uint8_t fifo_buff[1000] = {0};</div>
<div class="line"> </div>
<div class="line">    /* Modify the FIFO buffer instance and link to the device instance */</div>
<div class="line">    struct bmi160_fifo_frame fifo_frame;</div>
<div class="line">    fifo_frame.data = fifo_buff;</div>
<div class="line">    fifo_frame.length = 1000;</div>
<div class="line">    dev-&gt;fifo = &amp;fifo_frame;</div>
<div class="line"> </div>
<div class="line">    /* Declare instances of the sensor data structure to store the parsed FIFO data */</div>
<div class="line">    struct bmi160_aux_data aux_data[112]; //1000 / 9 bytes per frame ~ 111 data frames</div>
<div class="line"> </div>
<div class="line">    rslt = bmi160_init(dev);</div>
<div class="line">    printf(&quot;\n BMI160 chip ID is : %d &quot;,dev-&gt;chip_id);</div>
<div class="line"> </div>
<div class="line">    rslt = bmi160_aux_init(dev);</div>
<div class="line"> </div>
<div class="line">    rslt = bmm150_init(&amp;bmm150);</div>
<div class="line">    printf(&quot;\n BMM150 CHIP ID : %d&quot;,bmm150.chip_id);</div>
<div class="line"> </div>
<div class="line">    bmm150.settings.preset_mode = BMM150_PRESETMODE_LOWPOWER;</div>
<div class="line">    rslt = bmm150_set_presetmode(&amp;bmm150);</div>
<div class="line"> </div>
<div class="line">    bmm150.settings.pwr_mode = BMM150_FORCED_MODE;</div>
<div class="line">    rslt = bmm150_set_op_mode(&amp;bmm150);</div>
<div class="line"> </div>
<div class="line">    /* Enter the data register of BMM150 to &quot;auto_mode_addr&quot; here it is 0x42 */</div>
<div class="line">    auto_mode_addr = 0x42;</div>
<div class="line">    printf(&quot;\n ENTERING AUX. AUTO MODE &quot;);</div>
<div class="line">    dev-&gt;aux_cfg.aux_odr = BMI160_AUX_ODR_25HZ;</div>
<div class="line">    rslt = bmi160_set_aux_auto_mode(&amp;auto_mode_addr, dev);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    /* Disable other FIFO settings */</div>
<div class="line">    rslt = bmi160_set_fifo_config(BMI160_FIFO_CONFIG_1_MASK , BMI160_DISABLE, dev);</div>
<div class="line"> </div>
<div class="line">    /* Enable the required FIFO settings */</div>
<div class="line">    rslt = bmi160_set_fifo_config(BMI160_FIFO_AUX | BMI160_FIFO_HEADER, BMI160_ENABLE, dev);</div>
<div class="line"> </div>
<div class="line">    /* Delay for the FIFO to get filled */</div>
<div class="line">    dev-&gt;delay_ms(400);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    printf(&quot;\n FIFO DATA REQUESTED (in bytes): %d&quot;,dev-&gt;fifo-&gt;length);</div>
<div class="line">    rslt = bmi160_get_fifo_data(dev);</div>
<div class="line">    printf(&quot;\n FIFO DATA AVAILABLE (in bytes): %d&quot;,dev-&gt;fifo-&gt;length);</div>
<div class="line"> </div>
<div class="line">    /* Print the raw FIFO data obtained */</div>
<div class="line">    for(fifo_cnt = 0; fifo_cnt &lt; dev-&gt;fifo-&gt;length ; fifo_cnt++) {</div>
<div class="line">        printf(&quot;\n FIFO DATA [%d] IS : %x  &quot;,fifo_cnt ,dev-&gt;fifo-&gt;data[fifo_cnt]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(&quot;\n\n----------------------------------------------------\n&quot;);</div>
<div class="line"> </div>
<div class="line">    /* Set the number of required sensor data instances */</div>
<div class="line">    aux_instance = 150;</div>
<div class="line"> </div>
<div class="line">    /* Extract the aux data , 1frame = 8 data bytes */</div>
<div class="line">    printf(&quot;\n AUX DATA REQUESTED TO BE EXTRACTED (in frames): %d&quot;,aux_instance);</div>
<div class="line">    rslt = bmi160_extract_aux(aux_data, &amp;aux_instance, dev);</div>
<div class="line">    printf(&quot;\n AUX DATA ACTUALLY EXTRACTED (in frames): %d&quot;,aux_instance);</div>
<div class="line"> </div>
<div class="line">    /* Printing the raw aux data */</div>
<div class="line">    for (i = 0; i &lt; aux_instance; i++) {</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[0]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[1]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[2]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[3]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[4]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[5]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[6]);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x&quot;,i,aux_data[i].data[7]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(&quot;\n\n----------------------------------------------------\n&quot;);</div>
<div class="line"> </div>
<div class="line">    /* Compensate the raw mag data using BMM150 API */</div>
<div class="line">    for (i = 0; i &lt; aux_instance; i++) {</div>
<div class="line">        printf(&quot;\n----------------------------------------------------&quot;);</div>
<div class="line">        printf(&quot;\n Aux data[%d] : %x , %x , %x , %x , %x , %x , %x , %x&quot;,i</div>
<div class="line">                    ,aux_data[i].data[0],aux_data[i].data[1]</div>
<div class="line">                    ,aux_data[i].data[2],aux_data[i].data[3]</div>
<div class="line">                    ,aux_data[i].data[4],aux_data[i].data[5]</div>
<div class="line">                    ,aux_data[i].data[6],aux_data[i].data[7]);</div>
<div class="line"> </div>
<div class="line">        /* Compensated mag data using BMM150 API */</div>
<div class="line">        rslt = bmm150_aux_mag_data(&amp;aux_data[i].data[0], &amp;bmm150);</div>
<div class="line"> </div>
<div class="line">        /* Printing the  Compensated mag data */</div>
<div class="line">        if (rslt == BMM150_OK) {</div>
<div class="line">            printf(&quot;\n MAG DATA COMPENSATION USING BMM150 APIs&quot;);</div>
<div class="line">            printf(&quot;\n COMPENSATED DATA &quot;);</div>
<div class="line">            printf(&quot;\n MAG DATA X : %d  Y : %d      Z : %d&quot;</div>
<div class="line">                , bmm150.data.x, bmm150.data.y, bmm150.data.z);</div>
<div class="line"> </div>
<div class="line">        } else {</div>
<div class="line">            printf(&quot;\n MAG DATA COMPENSATION IN BMM150 API is FAILED &quot;);</div>
<div class="line">        }</div>
<div class="line">        printf(&quot;\n----------------------------------------------------\n&quot;);</div>
<div class="line">    }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md54"></a>
Self-test</h1>
<h3><a class="anchor" id="autotoc_md55"></a>
Example for performing accel self test</h3>
<div class="fragment"><div class="line">/* Call the &quot;bmi160_init&quot; API as a prerequisite before performing self test</div>
<div class="line"> * since invoking self-test will reset the sensor */</div>
<div class="line"> </div>
<div class="line">    rslt = bmi160_perform_self_test(BMI160_ACCEL_ONLY, sen);</div>
<div class="line">    /* Utilize the enum BMI160_GYRO_ONLY instead of BMI160_ACCEL_ONLY</div>
<div class="line">       to perform self test for gyro */</div>
<div class="line">    if (rslt == BMI160_OK) {</div>
<div class="line">        printf(&quot;\n ACCEL SELF TEST RESULT SUCCESS);</div>
<div class="line">    } else {</div>
<div class="line">        printf(&quot;\n ACCEL SELF TEST RESULT FAIL);</div>
<div class="line">    }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md56"></a>
FIFO</h1>
<h3><a class="anchor" id="autotoc_md57"></a>
Example for reading FIFO and extracting Gyro data in Header mode</h3>
<div class="fragment"><div class="line">/* An example to read the Gyro data in header mode along with sensor time (if available)</div>
<div class="line"> * Configure the gyro sensor as prerequisite and follow the below example to read and</div>
<div class="line"> * obtain the gyro data from FIFO */</div>
<div class="line">int8_t fifo_gyro_header_time_data(struct bmi160_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt = 0;</div>
<div class="line"> </div>
<div class="line">    /* Declare memory to store the raw FIFO buffer information */</div>
<div class="line">    uint8_t fifo_buff[300];</div>
<div class="line">    </div>
<div class="line">    /* Modify the FIFO buffer instance and link to the device instance */</div>
<div class="line">    struct bmi160_fifo_frame fifo_frame;</div>
<div class="line">    fifo_frame.data = fifo_buff;</div>
<div class="line">    fifo_frame.length = 300;</div>
<div class="line">    dev-&gt;fifo = &amp;fifo_frame;</div>
<div class="line">    uint16_t index = 0;</div>
<div class="line">    </div>
<div class="line">    /* Declare instances of the sensor data structure to store the parsed FIFO data */</div>
<div class="line">    struct bmi160_sensor_data gyro_data[42]; // 300 bytes / ~7bytes per frame ~ 42 data frames</div>
<div class="line">    uint8_t gyro_frames_req = 42; </div>
<div class="line">    uint8_t gyro_index;</div>
<div class="line">    </div>
<div class="line">    /* Configure the sensor&#39;s FIFO settings */</div>
<div class="line">    rslt = bmi160_set_fifo_config(BMI160_FIFO_GYRO | BMI160_FIFO_HEADER | BMI160_FIFO_TIME,</div>
<div class="line">                    BMI160_ENABLE, dev);</div>
<div class="line">                    </div>
<div class="line">    if (rslt == BMI160_OK) {</div>
<div class="line">        /* At ODR of 100 Hz ,1 frame gets updated in 1/100 = 0.01s</div>
<div class="line">        i.e. for 42 frames we need 42 * 0.01 = 0.42s = 420ms delay */</div>
<div class="line">        dev-&gt;delay_ms(420); </div>
<div class="line">    </div>
<div class="line">        /* Read data from the sensor&#39;s FIFO and store it the FIFO buffer,&quot;fifo_buff&quot; */</div>
<div class="line">        printf(&quot;\n USER REQUESTED FIFO LENGTH : %d\n&quot;,dev-&gt;fifo-&gt;length);</div>
<div class="line">        rslt = bmi160_get_fifo_data(dev);</div>
<div class="line"> </div>
<div class="line">        if (rslt == BMI160_OK) {</div>
<div class="line">            printf(&quot;\n AVAILABLE FIFO LENGTH : %d\n&quot;,dev-&gt;fifo-&gt;length);</div>
<div class="line">            /* Print the raw FIFO data */</div>
<div class="line">            for (index = 0; index &lt; dev-&gt;fifo-&gt;length; index++) {</div>
<div class="line">                printf(&quot;\n FIFO DATA INDEX[%d] = %d&quot;, index,</div>
<div class="line">                    dev-&gt;fifo-&gt;data[index]);</div>
<div class="line">            }</div>
<div class="line">            /* Parse the FIFO data to extract gyro data from the FIFO buffer */</div>
<div class="line">            printf(&quot;\n REQUESTED GYRO DATA FRAMES : %d\n &quot;,gyro_frames_req);</div>
<div class="line">            rslt = bmi160_extract_gyro(gyro_data, &amp;gyro_frames_req, dev);</div>
<div class="line"> </div>
<div class="line">            if (rslt == BMI160_OK) {</div>
<div class="line">                printf(&quot;\n AVAILABLE GYRO DATA FRAMES : %d\n &quot;,gyro_frames_req);</div>
<div class="line">                </div>
<div class="line">                /* Print the parsed gyro data from the FIFO buffer */</div>
<div class="line">                for (gyro_index = 0; gyro_index &lt; gyro_frames_req; gyro_index++) {</div>
<div class="line">                    printf(&quot;\nFIFO GYRO FRAME[%d]&quot;,gyro_index);</div>
<div class="line">                    printf(&quot;\nGYRO X-DATA : %d \t Y-DATA : %d \t Z-DATA : %d&quot;</div>
<div class="line">                        ,gyro_data[gyro_index].x ,gyro_data[gyro_index].y</div>
<div class="line">                        ,gyro_data[gyro_index].z);</div>
<div class="line">                }</div>
<div class="line">                /* Print the special FIFO frame data like sensortime */</div>
<div class="line">                printf(&quot;\n SENSOR TIME DATA : %d \n&quot;,dev-&gt;fifo-&gt;sensor_time);</div>
<div class="line">                printf(&quot;SKIPPED FRAME COUNT : %d&quot;,dev-&gt;fifo-&gt;skipped_frame_count);</div>
<div class="line">            } else {</div>
<div class="line">                printf(&quot;\n Gyro data extraction failed&quot;);</div>
<div class="line">            }</div>
<div class="line">        } else {</div>
<div class="line">            printf(&quot;\n Reading FIFO data failed&quot;);</div>
<div class="line">        }</div>
<div class="line">    } else {</div>
<div class="line">        printf(&quot;\n Setting FIFO configuration failed&quot;);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md58"></a>
FOC and offset compensation</h1>
<blockquote class="doxtable">
<p>FOC shouldnot be used in Low-power mode </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md59"></a>
Example for configuring FOC for accel and gyro</h3>
<div class="fragment"><div class="line">/* An example for configuring FOC for accel and gyro data */</div>
<div class="line">int8_t start_foc(struct bmi160_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt = 0;</div>
<div class="line">    /* FOC configuration structure */</div>
<div class="line">    struct bmi160_foc_conf foc_conf;</div>
<div class="line">    /* Structure to store the offsets */</div>
<div class="line">    struct bmi160_offsets offsets;</div>
<div class="line">    </div>
<div class="line">    /* Enable FOC for accel with target values of z = 1g ; x,y as 0g */</div>
<div class="line">    foc_conf.acc_off_en = BMI160_ENABLE;</div>
<div class="line">    foc_conf.foc_acc_x  = BMI160_FOC_ACCEL_0G;</div>
<div class="line">    foc_conf.foc_acc_y  = BMI160_FOC_ACCEL_0G;</div>
<div class="line">    foc_conf.foc_acc_z  = BMI160_FOC_ACCEL_POSITIVE_G;</div>
<div class="line">    </div>
<div class="line">    /* Enable FOC for gyro */</div>
<div class="line">    foc_conf.foc_gyr_en = BMI160_ENABLE;</div>
<div class="line">    foc_conf.gyro_off_en = BMI160_ENABLE;</div>
<div class="line"> </div>
<div class="line">    rslt = bmi160_start_foc(&amp;foc_conf, &amp;offsets, sen);</div>
<div class="line">    </div>
<div class="line">    if (rslt == BMI160_OK) {</div>
<div class="line">        printf(&quot;\n FOC DONE SUCCESSFULLY &quot;);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES AFTER FOC : &quot;);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES ACCEL X : %d &quot;,offsets.off_acc_x);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES ACCEL Y : %d &quot;,offsets.off_acc_y);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES ACCEL Z : %d &quot;,offsets.off_acc_z);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES GYRO  X : %d &quot;,offsets.off_gyro_x);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES GYRO  Y : %d &quot;,offsets.off_gyro_y);</div>
<div class="line">        printf(&quot;\n OFFSET VALUES GYRO  Z : %d &quot;,offsets.off_gyro_z);    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    /* After start of FOC offsets will be updated automatically and </div>
<div class="line">     * the data will be very much close to the target values of measurement */</div>
<div class="line"> </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md60"></a>
Example for updating the offsets manually</h3>
<blockquote class="doxtable">
<p>The offsets set by this method will be reset on soft-reset/POR </p>
</blockquote>
<div class="fragment"><div class="line">/* An example for updating manual offsets to sensor */</div>
<div class="line">int8_t write_offsets(struct bmi160_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt = 0;</div>
<div class="line">    /* FOC configuration structure */</div>
<div class="line">    struct bmi160_foc_conf foc_conf;</div>
<div class="line">    /* Structure to store the offsets */</div>
<div class="line">    struct bmi160_offsets offsets;</div>
<div class="line">    </div>
<div class="line">    /* Enable offset update for accel */</div>
<div class="line">    foc_conf.acc_off_en = BMI160_ENABLE;</div>
<div class="line"> </div>
<div class="line">    /* Enable offset update for gyro */</div>
<div class="line">    foc_conf.gyro_off_en = BMI160_ENABLE;</div>
<div class="line">    </div>
<div class="line">    /* offset values set by user */</div>
<div class="line">    offsets.off_acc_x = 0x10;</div>
<div class="line">    offsets.off_acc_y = 0x10;</div>
<div class="line">    offsets.off_acc_z = 0x10;</div>
<div class="line">    offsets.off_gyro_x = 0x10;</div>
<div class="line">    offsets.off_gyro_y = 0x10;</div>
<div class="line">    offsets.off_gyro_z = 0x10;</div>
<div class="line"> </div>
<div class="line">    rslt = bmi160_set_offsets(&amp;foc_conf, &amp;offsets, sen);</div>
<div class="line">    </div>
<div class="line">    /* After offset setting the data read from the </div>
<div class="line">     * sensor will have the corresponding offset */</div>
<div class="line">    </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md61"></a>
Example for updating the offsets into NVM</h3>
<blockquote class="doxtable">
<p>The offsets set by this method will be present in NVM and will be restored on POR/soft-reset </p>
</blockquote>
<div class="fragment"><div class="line">/* An example for updating manual offsets to sensor */</div>
<div class="line">int8_t write_offsets_nvm(struct bmi160_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt = 0;</div>
<div class="line">    /* FOC configuration structure */</div>
<div class="line">    struct bmi160_foc_conf foc_conf;</div>
<div class="line">    /* Structure to store the offsets */</div>
<div class="line">    struct bmi160_offsets offsets;</div>
<div class="line">    </div>
<div class="line">    /* Enable offset update for accel */</div>
<div class="line">    foc_conf.acc_off_en = BMI160_ENABLE;</div>
<div class="line"> </div>
<div class="line">    /* Enable offset update for gyro */</div>
<div class="line">    foc_conf.gyro_off_en = BMI160_ENABLE;</div>
<div class="line">    </div>
<div class="line">    /* offset values set by user as per their reference </div>
<div class="line">     * Resolution of accel = 3.9mg/LSB </div>
<div class="line">     * Resolution of gyro  = (0.061degrees/second)/LSB */</div>
<div class="line">    offsets.off_acc_x = 10;</div>
<div class="line">    offsets.off_acc_y = -15;</div>
<div class="line">    offsets.off_acc_z = 20;</div>
<div class="line">    offsets.off_gyro_x = 30;</div>
<div class="line">    offsets.off_gyro_y = -35;</div>
<div class="line">    offsets.off_gyro_z = -40;</div>
<div class="line"> </div>
<div class="line">    rslt = bmi160_set_offsets(&amp;foc_conf, &amp;offsets, sen);</div>
<div class="line">     </div>
<div class="line">    if (rslt == BMI160_OK) {</div>
<div class="line">        /* Update the NVM */</div>
<div class="line">        rslt = bmi160_update_nvm(dev);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    /* After this procedure the offsets are written to </div>
<div class="line">     * NVM and restored on POR/soft-reset </div>
<div class="line">     * The set values can be removed to ideal case by </div>
<div class="line">     * invoking the following APIs</div>
<div class="line">     *     - bmi160_start_foc()  </div>
<div class="line">     *     - bmi160_update_nvm()</div>
<div class="line">     */</div>
<div class="line"> </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md62"></a>
BMM150 sensor API</h1>
<h2><a class="anchor" id="autotoc_md63"></a>
Introduction</h2>
<p>This package contains the Bosch Sensortec's BMM150 Magnetometer sensor driver (sensor API)</p>
<p>The sensor driver package includes <a class="el" href="bmm150_8h.html">bmm150.h</a>, <a class="el" href="bmm150_8c.html" title="Sensor driver for BMM150 sensor.">bmm150.c</a> and <a class="el" href="bmm150__defs_8h.html">bmm150_defs.h</a> files</p>
<p>bmm150 sensor driver supports the following Bosch MEMS sensors</p><ul>
<li>BMM050</li>
<li>BMM150</li>
<li>BMC150 - Combination of bma2x2 + bmm150 APIs</li>
<li>BMC056 - Combination of bma2x2 + bmm150 APIs</li>
<li>BMX055 - Combination of bma2x2 + bmg160 + bmm150 APIs</li>
</ul>
<h2><a class="anchor" id="autotoc_md64"></a>
Version</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File </th><th class="markdownTableHeadNone">Version </th><th class="markdownTableHeadNone">Date  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="bmm150_8c.html" title="Sensor driver for BMM150 sensor.">bmm150.c</a> </td><td class="markdownTableBodyNone">1.0.0 </td><td class="markdownTableBodyNone">12 Sep 2017  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="bmm150_8h.html">bmm150.h</a> </td><td class="markdownTableBodyNone">1.0.0 </td><td class="markdownTableBodyNone">12 Sep 2017  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="bmm150__defs_8h.html">bmm150_defs.h</a> </td><td class="markdownTableBodyNone">1.0.0 </td><td class="markdownTableBodyNone">12 Sep 2017  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md65"></a>
Integration details</h2>
<ul>
<li>Integrate <a class="el" href="bmm150_8h.html">bmm150.h</a>, <a class="el" href="bmm150__defs_8h.html">bmm150_defs.h</a> and <a class="el" href="bmm150_8c.html" title="Sensor driver for BMM150 sensor.">bmm150.c</a> file in to your project.</li>
<li>Include the <a class="el" href="bmm150_8h.html">bmm150.h</a> file in your code like below. <div class="fragment"><div class="line">#include &quot;bmm150.h&quot;</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md66"></a>
File information</h2>
<ul>
<li><a class="el" href="bmm150__defs_8h.html">bmm150_defs.h</a> : This header file has the constants, macros and datatype declarations.</li>
<li><a class="el" href="bmm150_8h.html">bmm150.h</a> : This header file contains the declarations of the sensor driver APIs.</li>
<li><a class="el" href="bmm150_8c.html" title="Sensor driver for BMM150 sensor.">bmm150.c</a> : This source file contains the definitions of the sensor driver APIs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md67"></a>
Supported sensor interfaces</h2>
<ul>
<li>SPI 4-wire</li>
<li>I2C</li>
</ul>
<h2><a class="anchor" id="autotoc_md68"></a>
Usage guide</h2>
<h3><a class="anchor" id="autotoc_md69"></a>
Initializing the sensor</h3>
<p>To initialize the sensor, you will first need to create a device structure. You can do this by creating an instance of the structure <a class="el" href="structbmm150__dev.html" title="bmm150 device structure">bmm150_dev</a>. Then go on to fill in the various parameters as shown below.</p>
<h4><a class="anchor" id="autotoc_md70"></a>
Example for SPI 4-Wire</h4>
<div class="fragment"><div class="line">struct bmm150_dev dev;</div>
<div class="line">int8_t rslt = BMM150_OK;</div>
<div class="line"> </div>
<div class="line">/* Sensor interface over SPI with native chip select line */</div>
<div class="line">dev.dev_id = 0;</div>
<div class="line">dev.intf = BMM150_SPI_INTF;</div>
<div class="line">dev.read = user_spi_read;</div>
<div class="line">dev.write = user_spi_write;</div>
<div class="line">dev.delay_ms = user_delay_ms;</div>
<div class="line"> </div>
<div class="line">rslt = bmm150_init(&amp;dev);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md71"></a>
Example for I2C</h4>
<div class="fragment"><div class="line">struct bmm150_dev dev;</div>
<div class="line">int8_t rslt = BMM150_OK;</div>
<div class="line"> </div>
<div class="line">/* Sensor interface over I2C */</div>
<div class="line">dev.dev_id = BMM150_DEFAULT_I2C_ADDRESS;</div>
<div class="line">dev.intf = BMM150_I2C_INTF;</div>
<div class="line">dev.read = user_i2c_read;</div>
<div class="line">dev.write = user_i2c_write;</div>
<div class="line">dev.delay_ms = user_delay_ms;</div>
<div class="line"> </div>
<div class="line">rslt = bmm150_init(&amp;dev);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md72"></a>
Sensor Configuration settings</h3>
<h4><a class="anchor" id="autotoc_md73"></a>
Setting Normal operation mode (power mode) and preset mode.</h4>
<p><a class="anchor" id="autotoc_md74"></a></p><h5>Example for configuring the sensor in normal power mode and Low power preset mode</h5>
<div class="fragment"><div class="line">int8_t set_sensor_settings(struct bmm150_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line"> </div>
<div class="line">    /* Setting the power mode as normal */</div>
<div class="line">    dev-&gt;settings.pwr_mode = BMM150_NORMAL_MODE;</div>
<div class="line">    rslt = bmm150_set_op_mode(dev);</div>
<div class="line">    </div>
<div class="line">    /* Setting the preset mode as Low power mode </div>
<div class="line">    i.e. data rate = 10Hz XY-rep = 1 Z-rep = 2*/</div>
<div class="line">    dev-&gt;settings.preset_mode = BMM150_PRESETMODE_LOWPOWER;</div>
<div class="line">    rslt = bmm150_set_presetmode(dev);</div>
<div class="line">    </div>
<div class="line">    return rslt;    </div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md75"></a>
Reading sensor data</h3>
<ul>
<li>Sensor data should be read after setting the desired power mode and preset mode. </li>
</ul>
<h4><a class="anchor" id="autotoc_md76"></a>
Example for reading sensor data - Fixed point version</h4>
<blockquote class="doxtable">
<p>Ensure that the macro "BMM150_USE_FLOATING_POINT" in the <a class="el" href="bmm150__defs_8h.html">bmm150_defs.h</a> file is commented out </p>
</blockquote>
<div class="fragment"><div class="line">int8_t read_sensor_data(struct bmm150_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line"> </div>
<div class="line">    /* Mag data for X,Y,Z axis are stored inside the</div>
<div class="line">    bmm150_dev structure in int16_t format */</div>
<div class="line">    rslt = bmm150_read_mag_data(dev);</div>
<div class="line"> </div>
<div class="line">    /* Print the Mag data */</div>
<div class="line">    printf(&quot;\n Magnetometer data \n&quot;);</div>
<div class="line">    printf(&quot;MAG X : %d \t MAG Y : %d \t MAG Z : %d \n&quot;</div>
<div class="line">        ,dev-&gt;data.x, dev-&gt;data.y, dev-&gt;data.z);</div>
<div class="line">    </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md77"></a>
Example for reading sensor data - Floating point version</h4>
<blockquote class="doxtable">
<p>Enable the macro "BMM150_USE_FLOATING_POINT" in the <a class="el" href="bmm150__defs_8h.html">bmm150_defs.h</a> file (or) enable "BMM150_USE_FLOATING_POINT" in the compiler option of your project </p>
</blockquote>
<div class="fragment"><div class="line">int8_t read_sensor_data(struct bmm150_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line"> </div>
<div class="line">    /* Mag data for X,Y,Z axis are stored inside the</div>
<div class="line">    bmm150_dev structure in float format */</div>
<div class="line">    rslt = bmm150_read_mag_data(dev);</div>
<div class="line"> </div>
<div class="line">    /* Print the Mag data */</div>
<div class="line">    printf(&quot;\n Magnetometer data \n&quot;);</div>
<div class="line">    printf(&quot;MAG X : %0.2f \t MAG Y : %0.2f \t MAG Z : %0.2f \n&quot;</div>
<div class="line">        ,dev-&gt;data.x, dev-&gt;data.y, dev-&gt;data.z);</div>
<div class="line">    </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md78"></a>
Self test - Normal self test and Advanced self test</h3>
<h4><a class="anchor" id="autotoc_md79"></a>
Example for performing Normal self test and Advanced self test</h4>
<div class="fragment"><div class="line">int8_t perform_self_tests(struct bmm150_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line"> </div>
<div class="line">    /* Perform Normal Self test */</div>
<div class="line">    rslt = bmm150_perform_self_test(BMM150_NORMAL_SELF_TEST, dev);</div>
<div class="line">    printf(&quot;\n NORMAL SELF TEST RESULT :  %d&quot;,rslt);</div>
<div class="line">    </div>
<div class="line">    /* Validate normal self test result */</div>
<div class="line">    if (rslt == BMM150_OK) {</div>
<div class="line">        printf(&quot;\n Normal Self test passed &quot;);</div>
<div class="line">    } else {</div>
<div class="line">        printf(&quot;\n Normal Self test failed &quot;);</div>
<div class="line">    }</div>
<div class="line">    /* Perform Advanced Self test */</div>
<div class="line">    rslt |= bmm150_perform_self_test(BMM150_ADVANCED_SELF_TEST, dev);</div>
<div class="line">    printf(&quot;\n ADVANCED SELF TEST RESULT : %d&quot;,rslt);</div>
<div class="line"> </div>
<div class="line">    /* Validate Advanced self test result */</div>
<div class="line">    if (rslt == BMM150_OK) {</div>
<div class="line">        printf(&quot;\n Advanced Self test passed &quot;);</div>
<div class="line">    } else {</div>
<div class="line">        printf(&quot;\n Advanced Self test failed &quot;);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md80"></a>
Interrupt settings</h3>
<h4><a class="anchor" id="autotoc_md81"></a>
Example for using Data ready interrupt to read data</h4>
<blockquote class="doxtable">
<p>Configuring the interrupt </p>
</blockquote>
<div class="fragment"><div class="line">int8_t drdy_interrupt_configure(struct bmm150_dev *dev)</div>
<div class="line">{</div>
<div class="line">    int8_t rslt;</div>
<div class="line">    uint16_t desired_settings;</div>
<div class="line"> </div>
<div class="line">    /* Set the macros to enable DRDY pin */</div>
<div class="line">    desired_settings = BMM150_DRDY_PIN_EN_SEL | BMM150_DRDY_POLARITY_SEL;</div>
<div class="line">    /* Set the drdy_pin_en to enable the drdy interrupt  */</div>
<div class="line">    dev-&gt;settings.int_settings.drdy_pin_en = BMM150_INT_ENABLE;</div>
<div class="line">    /* Set the polarity as active high on the DRDY pin */</div>
<div class="line">    dev-&gt;settings.int_settings.drdy_polarity = BMM150_ACTIVE_HIGH_POLARITY; </div>
<div class="line">    </div>
<div class="line">    /* Set the configurations in the sensor */</div>
<div class="line">    rslt = bmm150_set_sensor_settings(desired_settings, dev);</div>
<div class="line">    </div>
<div class="line">    return rslt;</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Read the interrupt status continuously to check for interrupt assertion (Polling method) </p>
</blockquote>
<p>``` c int8_t drdy_interrupt_handling(struct bmm150_dev *dev) { int8_t rslt;</p>
<p>/* Read the interrupt status */ rslt = bmm150_get_interrupt_status(dev); if (rslt == BMM150_OK) { if (dev-&gt;int_status &amp; BMM150_DATA_READY_INT) { /* Interrupt asserted - Read mag data */ rslt = bmm150_read_mag_data(dev); printf("\n MAG DATA "); printf("\n MAG X : %d MAG Y : %d MAG Z : %d " ,dev-&gt;data.x,dev-&gt;data.y,dev-&gt;data.z); } else { /*Interrupt not asserted */ printf("\n Data is not ready yet"); } }</p>
<p>return rslt; }</p>
<h2><a class="anchor" id="autotoc_md82"></a>
Copyright (C) 2019 Bosch Sensortec GmbH</h2>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
